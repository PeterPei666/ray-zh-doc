

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>教程 &mdash; Ray 0.3.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Ray 0.3.0 documentation" href="index.html"/>
        <link rel="next" title="The Ray API" href="api.html"/>
        <link rel="prev" title="Installation Troubleshooting" href="installation-troubleshooting.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Ray
          

          
          </a>

          
            
            
              <div class="version">
                0.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">安装</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install-on-ubuntu.html">在 Ubuntu 上进行安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="install-on-macosx.html">Installation on Mac OS X</a></li>
<li class="toctree-l1"><a class="reference internal" href="install-on-docker.html">Installation on Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation-troubleshooting.html">Installation Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">开始使用</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">教程</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">总览</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ray">启动 Ray</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">不可改变的远程对象</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#put-get">推送 Put 和 获取 Get</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ray-asynchronous-computation">Ray 中的异步计算 Asynchronous Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#remote-functions">远程函数 Remote functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">表达任务之间的依赖关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">远程函数中的远程函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">The Ray API</a></li>
<li class="toctree-l1"><a class="reference internal" href="actors.html">Actors</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ray-with-gpus.html">Using Ray with GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="tune.html">Ray.tune: Hyperparameter Optimization Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="rllib.html">Ray RLlib: A Scalable Reinforcement Learning Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="rllib-dev.html">RLlib Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="webui.html">Web UI</a></li>
</ul>
<p class="caption"><span class="caption-text">样例</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="example-hyperopt.html">Hyperparameter Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-rl-pong.html">Learning to Play Pong</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-policy-gradient.html">Policy Gradient Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-parameter-server.html">Parameter Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-resnet.html">ResNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-a3c.html">Asynchronous Advantage Actor Critic (A3C)</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-lbfgs.html">Batch L-BFGS</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-evolution-strategies.html">Evolution Strategies</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-cython.html">Cython</a></li>
<li class="toctree-l1"><a class="reference internal" href="example-streaming.html">Streaming MapReduce</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ray-with-tensorflow.html">Using Ray with TensorFlow</a></li>
</ul>
<p class="caption"><span class="caption-text">设计</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals-overview.html">An Overview of the Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="serialization.html">Serialization in the Object Store</a></li>
<li class="toctree-l1"><a class="reference internal" href="fault-tolerance.html">Fault Tolerance</a></li>
<li class="toctree-l1"><a class="reference internal" href="plasma-object-store.html">The Plasma Object Store</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">Resource (CPUs, GPUs)</a></li>
</ul>
<p class="caption"><span class="caption-text">集群使用</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="autoscaling.html">Cloud Setup and Auto-Scaling</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ray-on-a-cluster.html">Using Ray on a Cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ray-on-a-large-cluster.html">Using Ray on a Large Cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="using-ray-and-docker-on-a-cluster.html">Using Ray and Docker on a Cluster (EXPERIMENTAL)</a></li>
</ul>
<p class="caption"><span class="caption-text">帮助</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ray</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>教程</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>教程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>为了使用 Ray，你需要理解下面两点：</p>
<ul class="simple">
<li>Ray 如何异步执行任务来达到并行的效果</li>
<li>Ray 如何使用对象 ID 来表示不可改变的远程对象</li>
</ul>
<div class="section" id="id2">
<h2>总览<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Ray 是一个基于 Python 的分布式执行引擎. 同样的代码可以在单机上达到有效的多进程效果，同样也可以在集群上进行大规模的计算.</p>
<p>在使用 Ray 的时候，会包含下面几个过程</p>
<ul class="simple">
<li>多个 <strong>worker</strong> 进程执行任务并存放结果在对象存储中. 每个 worker 是分隔开的进程.</li>
<li>每个节点有一个 <strong>对象存储</strong> 存放了不可改变的对象在共享内存中，允许 workers 以极小的复制和去序列化代价有效地在同一个节点上共享对象.</li>
<li>每个节点有一个 <strong>本地调度器 local scheduler</strong> 分配任务给在同一个节点上的 workers.</li>
<li><strong>全局调度器 global scheduler</strong> 接受来自本地调度器的任务并将任务分配给其他本地调度器</li>
<li><strong>driver</strong> 是用户控制的 Python 进程. 如，如果用户运行一个脚本或者使用 Python shell，那么 driver 就是运行脚本或者 shell 的进程. driver 类似于 worker，因为它可以提交任务给它的本地调度器，与 worker 不同的地方在于本地调度器不会分配任务给 driver 去执行.</li>
<li><strong>Redis 服务器</strong> 保存了系统大部分的状态. 如，它会跟踪哪个对象在哪台机器，也会保存任务的规格 specification（但不会包含数据）. 它同样能够直接进行查询供调试使用.</li>
</ul>
</div>
<div class="section" id="ray">
<h2>启动 Ray<a class="headerlink" href="#ray" title="Permalink to this headline">¶</a></h2>
<p>启动 Python，运行下面命令就可以启动 Ray</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ray</span>
<span class="n">ray</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
</pre></div>
</div>
<p>这就可以启动 Ray.</p>
</div>
<div class="section" id="id3">
<h2>不可改变的远程对象<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>在 Ray 中，我们可以创建和计算对象. 我们将这些对象称为 <strong>remote objects</strong>，
并且我们使用 <strong>对象 ID</strong> 来引用他们. 远程对象存放在 <strong>对象存储 object stores</strong> 中，在集群中每个节点有一个对象存储.
在集群中，我们可能不知道每个对象在哪台机器上.</p>
<p>一个 <strong>对象 ID</strong> 本质上是一个独一无二 ID 可以用来引用一个远程对象. 如果你熟悉 <a class="reference external" href="https://docs.rs/futures/0.1.17/futures/">Futures</a>，我们的对象 ID 其实很类似.</p>
<p>我们假设远程对象是不可改变的. 也就是说，他们的值在创建后不能改变. 这使得远程对象被复制到多个对象存储中时不需要同步这些副本.</p>
<div class="section" id="put-get">
<h3>推送 Put 和 获取 Get<a class="headerlink" href="#put-get" title="Permalink to this headline">¶</a></h3>
<p>命令 <code class="docutils literal"><span class="pre">ray.get</span></code> 和 <code class="docutils literal"><span class="pre">ray.put</span></code> 可以用来进行 Python 对象和对象 ID 之间的转换，如下例所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;example&quot;</span>
<span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># ObjectID(b49a32d72057bdcfc4dda35584b3d838aad89f5d)</span>
</pre></div>
</div>
<p>命令 <code class="docutils literal"><span class="pre">ray.put(x)</span></code> 会由一个 worker 进程或者由 driver 进程运行（driver 进程就是运行脚本的进程）.
它会接受一个 Python 对象，并复制其到本地对象存储中（这里的 local 表示存在于同一个节点）.
一旦对象被存入对象存储中，其值将不能改变.</p>
<p>另外，<code class="docutils literal"><span class="pre">ray.put(x)</span></code> 返回一个对象 ID，这是一个可以用来引用新创建的远程对象的 ID. 如果我们保存对象 ID 在变量中 <code class="docutils literal"><span class="pre">x_id</span> <span class="pre">=</span> <span class="pre">ray.put(x)</span></code>，那么我们可以传递 <code class="docutils literal"><span class="pre">x_id</span></code> 给远程
函数，这些远程函数可以在对应的远程对象上进行操作</p>
<p>命令 <code class="docutils literal"><span class="pre">ray.get(x_id)</span></code> 以一个对象 ID 为输入，从对应的远程对象创建一个 Python 对象.</p>
<p>对于某项对象比如数组，我们可以使用共享内容，避免复制对象. 对其他的对象，这会复制对象从对象存储到 worker 的进程堆中.
如果对应于对象 ID <code class="docutils literal"><span class="pre">x_id</span></code> 远程对象在 worker 调用 <code class="docutils literal"><span class="pre">ray.get(x_id)</span></code> 时不再存在与同样的节点上，
远程对象将会首先从存放它的对象存储中转移到需要它的对象存储中.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x_id</span><span class="p">)</span>  <span class="c1"># &quot;example&quot;</span>
</pre></div>
</div>
<p>如果对应于目标 ID <code class="docutils literal"><span class="pre">x_id</span></code> 远程对象还没有被创建，命令 <code class="docutils literal"><span class="pre">ray.get(x_id)</span></code> 将会等待直到远程对象被创建.</p>
<p>非常通用的使用 <code class="docutils literal"><span class="pre">ray.get</span></code> 是获取对象 ID 的列表，这种情况下，你可以调用 <code class="docutils literal"><span class="pre">ray.get(object_ids)</span></code> 其中 <code class="docutils literal"><span class="pre">object_ids</span></code> 是对象 ID 的列表.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">result_ids</span><span class="p">)</span>  <span class="c1"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ray-asynchronous-computation">
<h2>Ray 中的异步计算 Asynchronous Computation<a class="headerlink" href="#ray-asynchronous-computation" title="Permalink to this headline">¶</a></h2>
<p>Ray 能够让任意的 Python 函数异步执行. 这是通过指定 Python 函数为一个 <strong>远程函数</strong> 达成的. <a href="#id4"><span class="problematic" id="id5">**</span></a>.</p>
<p>例如，正常的 Python 函数是下面这样的：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>远程函数长成这样.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">add2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<div class="section" id="remote-functions">
<h3>远程函数 Remote functions<a class="headerlink" href="#remote-functions" title="Permalink to this headline">¶</a></h3>
<p>调用 <code class="docutils literal"><span class="pre">add1(1,</span> <span class="pre">2)</span></code> 返回 <code class="docutils literal"><span class="pre">3</span></code> 会让 Python 解释器锁住直到计算完成. 调用 <code class="docutils literal"><span class="pre">add2.remote(1,</span> <span class="pre">2)</span></code>
立即会返回一个对象 ID 并创建一个 <strong>任务</strong>. 这个任务将会被系统调度并异步执行（也可能在不同的机器上进行）.
在任务完成运行后，其返回值将会被存放在对象存储中.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x_id</span> <span class="o">=</span> <span class="n">add2</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x_id</span><span class="p">)</span>  <span class="c1"># 3</span>
</pre></div>
</div>
<p>下面简单例子展示了异步任务如何进行并行计算.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># The following takes ten seconds.</span>
<span class="p">[</span><span class="n">f1</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># The following takes one second (assuming the system has at least ten CPUs).</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="n">f2</span><span class="o">.</span><span class="n">remote</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
</pre></div>
</div>
<p>在 <em>提交任务</em> 和 <em>执行任务</em> 之间有一个非常明显的差异.
当一个远程函数被调用时，执行那个函数的任务被提交到一个本地调度器，
而那个任务的输出的对象 ID 会立即返回. 但是，这个任务一直到系统实际在一个 worker 上被调度才能执行.
任务执行并不是懒惰完成的. Task execution is <strong>not</strong> done lazily.
系统将输入数据移入这个任务，这个任务将会在其输入依赖条件都已经满足，并且有足够资源完成计算的时候执行.</p>
<p><strong>当任务被提交时，每个参数可能会被按值或者按对象 ID 传入.</strong> 例如，下面代码有同样的行为.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">add2</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">add2</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">add2</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>远程函数永不返回实际值，总是返回对象 ID.</p>
<p>当远程函数实际执行时，它会操作 Python 对象.
也就是说，如果远程函数被任何对象 ID 调用，系统会从对象存储中检索对应的对象.</p>
<p>注意一个远程函数可以返回多个对象 ID.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@ray.remote</span><span class="p">(</span><span class="n">num_return_vals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">return_multiple</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>

<span class="n">a_id</span><span class="p">,</span> <span class="n">b_id</span><span class="p">,</span> <span class="n">c_id</span> <span class="o">=</span> <span class="n">return_multiple</span><span class="o">.</span><span class="n">remote</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>表达任务之间的依赖关系<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>程序员可以表示任务之间的依赖关系通过传入一个任务的对象 ID 输出作为到另一个任务.
例如，我们可以启动三个任务，每个都依赖于前一个任务：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c1"># 3</span>
</pre></div>
</div>
<p>第二个任务将会等到第一个完成后才执行，第三个会在第二个完成后执行. 在这个例子中，并没有并行的机会.</p>
<p>编写任务的能力让我们很容易表达有趣的依赖关系. 看一下下面的 tree reduce 的实现.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">generate_data</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">aggregate_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="c1"># Generate some random data. This launches 100 tasks that will be scheduled on</span>
<span class="c1"># various nodes. The resulting data will be distributed around the cluster.</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_data</span><span class="o">.</span><span class="n">remote</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>

<span class="c1"># Perform a tree reduce.</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aggregate_data</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

<span class="c1"># Fetch the result.</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>远程函数中的远程函数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>目前为止，我们已经从 driver 处调用远程函数. 但是 worker 进程也可以调用远程函数.
为了解释这点，我们看一下下面的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">sub_experiment</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="c1"># Run the jth sub-experiment for the ith experiment.</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>

<span class="nd">@ray.remote</span>
<span class="k">def</span> <span class="nf">run_experiment</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">sub_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Launch tasks to perform 10 sub-experiments in parallel.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">sub_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_experiment</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
    <span class="c1"># Return the sum of the results of the sub-experiments.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sub_results</span><span class="p">))</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">run_experiment</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="c1"># [45, 55, 65, 75, 85]</span>
</pre></div>
</div>
<p>当远程函数 <code class="docutils literal"><span class="pre">run_experiment</span></code> 在 worker 上执行时，它调用了数次远程函数 <code class="docutils literal"><span class="pre">sub_experiment</span></code>.
这是多实验的例子，每个都利用了并行的好处，能够并行执行</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api.html" class="btn btn-neutral float-right" title="The Ray API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation-troubleshooting.html" class="btn btn-neutral" title="Installation Troubleshooting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The Ray Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>